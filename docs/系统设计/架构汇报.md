[[toc]]

# 自定义平台 3.0 前端架构汇报

## 1. 引言

### 1.1. 背景

我们将打造易于扩展的自定义平台 3.0 平台，赋予`非技术人`员生产`业务系统`的能力，降低业务生产门槛，提高业务交付效率。

### 1.2. 痛点

#### 1.2.1. 业务痛点

2.0 核心痛点在于：`“业务扩展成本太高”`。

从 2.3 版本迭代到 2.4 版本，`时间周期长`，`参与人员多`，`部署成本高`等，都在增加整体的成本。

#### 1.2.2. 技术痛点

| 自定义平台 2.x 前端问题 | 自定义平台 3.0 优化方案 |
|---|---|
| 没有可以被遵守的规则 | 通过规则工具让规则可以被遵守 |
| 缺少对于自动集成测试的整体链路支持 | 需要从架构设计时考虑自动集成测试方案 |
| 技术术语不统一不明确 | 明确所有技术术语 |
| 项目架构缺乏扩展性 | 采用开源社区认可的 `monorepo` 工程管理方案 |

#### 1.2.3. 如何规避技术风险

我们的策略是：制定能被遵守的规则。

我们在 3.0 前端工程中引入了规则约束工具，约束每个开发者，从技术上避免 2.0 由于缺少各种规则约束导致的问题：

| 工具 | 作用 |
|---|---|
| typescript | 静态语法检查工具，让前端面向接口编程，检查并约束模块输入输出，可以减少 50% 人为疏忽导致的程序逻辑错误 |
| eslint | 编码规范检查工具，约束开发人员编码行为，减少 30% 的人为错误 |
| react | 高性能的 UI 渲染工具，单向数据流思想，避免 50% 由于混乱的程序运行数据导致的问题 |
| redux | 单向数据流实施工具，贯彻 “数据 -> UI 渲染” 的单向思维 |
| jest | 前端单元测试工具，确保模块运行时输入输出的符合预期的终极手段 |
| cypress | 集成测试工具，确保业务主流程没有问题的手段 |
| lerna | 工程目录结构管理工具，更好的组织工程代码 |

### 1.3. 设计原则

1. 第一原则：指导业务拆解与系统设计
   1. 指导业务需求拆解
   2. 指导系统设计
2. 原子设计原则： 系统架构原则，从最小单元考虑
3. 单向数据流确保数据正确性
4. 解析引擎支撑系统核心
5. 领域模型指导功能模块设计
6. 单元测试先行：保障核心模块的稳定性
7. 规则必须有落地方案，否则不制定规则
8. SOLID

### 1.4. 架构目标

用最小的人力成本来满足构建和维护系统的需求。

### 1.5. 愿景

打造通用的`低代码平台`产品，以应对未来将业务扩展到各行业。

---

## 2. 编写目的和范围

- 汇报自定义平台 3.0 前端的架构
- 说明框架支持业务组件扩展的方案

---

## 3. 业务领域模型

### 3.1. 总揽

`自定义平台 - 前端`从业务领域上分析，是一种典型的`生产者与消费者`模式，我们将配置平台视为`生产者`，产出`页面数据`，`页面数据`给应用平台前端`消费`：

![图片描述](/tfl/pictures/202007/tapd_41909965_1596009750_82.png)

---

### 3.2. 配置平台

1. 配置人员通过`配置平台`的可视化操作，产出可以直接应用于业务场景的系统
2. 配置平台赋予`配置人员`极高的生产力
3. 产出的`应用实例`拥有`业务数据录入`、`业务数据展示`、`物联网控制`等功能
4. 可以通过插件来扩展`配置平台`的能力

![图片描述](/tfl/pictures/202008/tapd_41909965_1597063145_2.png)

### 3.3. 应用平台

`应用实例`拥有`业务数据录入`、`业务数据展示`、`物联网控制`等为特定领域制定的业务功能：

![图片描述](/tfl/pictures/202008/tapd_41909965_1597063176_75.png)

---

## 4. 系统分层设计

<!-- ### 4.1. 基于业务的系统设计

`业务` -> `业务单元` -> `业务建模` -> `业务引擎` -> `业务系统`。 -->

### 4.1. 系统架构设计思路

`前端基础设施` -> `内核` -> `引擎` -> `业务插件` -> `子应用` -> `业务系统`。

![图片描述](/tfl/pictures/202007/tapd_41909965_1596011439_66.png)

核心思路是：核心能力由`引擎`提供，`业务`作为`插件`的形式插入到引擎运行，最终通过`内核`将多个引擎集合起来组成不同的`子应用`，最终成为可支持实际业务场景的`系统`。

---

### 4.2. 前端基础设施

当我们需要启动前端应用的开发的时候，往往会做很多重复的工作：

1. 技术选型
2. 工程目录划分、搭建、后期维护管理等
3. 通用模块，例如 `HTTP/WS` 模块，`UI`库等
4. 单元测试
5. ...

这些无论是什么前端项目，都是需要的，我们称之为`前端基础设施`。我们可以基于`前端基础设施`快速开启应用的开发，同时也方便后期的项目维护：

![图片描述](/tfl/pictures/202007/tapd_41909965_1596011451_40.png)

#### 4.2.1. 基础设施赋能

1. 通过 lerna 和 yarn workspace 提供的模块管理，赋予项目极高的可扩展性、可维护性
   1. 关键模块的依赖不再使用`相对路径`
2. 每个子应用可独立开发、调试、部署

---

### 4.3. 配置平台

1. 配置平台前端基于`前端基础设施`

![图片描述](/tfl/pictures/202009/tapd_41909965_1598942895_86.png)

### 4.4. 应用平台

1. 应用平台前端基于`前端基础设施`

![图片描述](/tfl/pictures/202007/tapd_41909965_1596079589_18.png)

---

## 5. 组件

自定义平台 - 前端的难点在于：需要对多样的、复杂的、组合的业务组件的支持。我们假设这些组件是架构时`未知的`。

因此，我们的架构的难点就在于此：如何包含`无尽的`，`未知的`业务组件。

### 5.1. 组件的本质

我们先分析组件的本质：`组件类型` + 该类型的`所有属性`。

![图片描述](/tfl/pictures/202009/tapd_41909965_1599979153_86.png)

<!-- 在前端框架 react 中，`组件类型`即我们通过扩展 `React.Component`的组件，`所有属性`即该`组件类型`的 `props`：

```tsx
// 这里是「所有属性」
interface CustomCompProps {
   // 响应用户的点击
   onClick: (event) => void
}

// 这里是我们定义的「组件类型」
class CustomComp extends React.Component<CustomCompProps> {
   render() {
      const { onClick } = this.props;
      return (
         <div onClick={onClick}>自定义组件</div>
      )
   }
}
``` -->

### 5.2. 组件的类型

在 GUI （图形界面）中，所有组件都同时具备两种功能：`数据录入`、`数据展示`。不同的是不同的 UI 组件是有`主要意图`的，我们按照 UI 的`主要意图`来给组件分类：

[pic]

#### 5.2.1. 数据录入组件

例如`单行输入框`、`选择器`等。

数据录入组件是指：给定默认选项，响应用户的输入交互。__数据提交为主，数据展示为辅。__

#### 5.2.2. 数据展示组件

例如`表格`、`图标`、`列表`等。

数据展示组件组件是指：根据给定数据，将数据可视化地展示给用户。适当的提供响应用户的交互的功能，例如`移动元素`、`更新数据`等。__数据展示为主，数据提交为辅。__

### 5.3. 框架与组件的关系

自定义平台 3.0 前端框架是一个`提供组件交互环境`的舞台。接入到框架中的组件称之为`业务组件`，可以通过`插件`的方式插入到框架中，即可运行。

![图片描述](/tfl/pictures/202009/tapd_41909965_1599979629_8.png)

#### 5.3.1. 业务组件

接入自定义平台 3.0 框架的组件，我们称之为`业务组件`。业务组件包含上述的对于组件的定义：`组件类型` + 该类型的`所有属性`。

组件准备好了，还需要一个`运行环境`来运行组件，提供组件之间的交互的能力。这个环境我们称之为：`变量体系`。

### 5.4. 变量体系

自定义平台 3.0 前端框架将提供一个`变量体系`，支持`组件之间的交互`，`页面之间的组件的交互`。

我们通过一个公式来认识一下最基本的逻辑：`变量 = 组件的属性在运行时的值`。这样组件之间便可通过`变量`引用到目标组件的属性的值：

![图片描述](/tfl/pictures/202009/tapd_41909965_1599979231_20.png)

### 5.5. 表格组件

表格的本质是`列(column)` + `行(row)`的集合。

![图片描述](/tfl/pictures/202009/tapd_41909965_1599979256_15.png)

#### 5.5.1. 列的定义

我们可以通过数据结构来描述`列`：

```ts
// 列的元数据
Column = {
   // 列名
   field: 'username',
   // 表头显示的名字
   title: '用户名',
   // 在这一列中渲染的每一项行数据的过滤器
   filter: (column, dataItem) => {
      if(dataItem.username == '张三') {
         return '显示'
      } else {
         return '不显示'
      }
   },
}
```

#### 5.5.2. 行数据

`行数据`是指表中的`业务数据`，例如：

```ts
RowData = [
   {
      username: '张三',
      age: 20
   }
]
```

`列定义`是用于描述`行数据`中的单个项中的属性的。

#### 5.5.3. 组件实现

我们只需要把列和行的数据传入`Table 表格组件`，即可渲染出表格。

```tsx
<Table columns={columns} dataSource={rowData} />
```

#### 5.5.4. 接入变量体系

上面是对于表格组件的分析，在自定义平台 3.0 的框架中，表格组件也是可以运行在变量体系之中的。

我们可以为`表格组件`定义更多的`变量`，注册到`变量体系`中，来满足业务需求，例如：

- 被选中的单元格：第 n 列 第 m 行，用数据结构表述：`selectedCell = { col: n, row: m }`
- 被选择的行：`selectedRow: { row: m }`
- ...

这些变量的定义是根据实际业务需要来确定的，并且其他组件可以通过通过`变量体系`获取这些值。

### 5.6. 动态表格

动态表格与表格的最大不同在于：基于表格的基础上，增加了可以编辑`行数据`的功能：

![图片描述](/tfl/pictures/202009/tapd_41909965_1599979313_17.png)

这时候我们只需扩展`列的定义`，并且增加一个`编辑中的行`的状态，即可达到该效果：

```ts
// 列的元数据
const Column = {
   // 列名
   field: 'username',
   // 表头显示的名字
   title: '用户名',
   // 编辑状态下，该列的行数据表现的状态
   editState: {
      // 编辑状态下为输入框
      component: 'Input'
   }
}
```

### 5.7. 其他业务组件

自定义平台 3.0 前端框架是一个`提供组件交互环境`的舞台。我们通过提供`变量体系`，让组件充分解偶，用最简单的规则提升组件的数据交互能力，这也是前端框架可以容纳尽可能多的业务组件的大前提。

业务组件只要按照框架提供的接入标准接入即可，随着业务的增长，将会有更多不同形态的业务组件被开发使用。

---

## 6. 感谢

感谢收看
